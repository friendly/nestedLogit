---
title: "Nested dichotomies logistic regression models"
author: "Michael Friendly and John Fox"
date: "`r Sys.Date()`"
package: nestedLogit
output: 
  rmarkdown::html_vignette:
  fig_caption: yes
bibliography: ["references.bib", "packages.bib"]
csl: apa.csl
vignette: >
  %\VignetteIndexEntry{Nested dichotomies logistic regression models}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  message = FALSE,
  warning = FALSE,
  fig.align = "center",
  fig.height = 6,
  fig.width = 7,
  fig.path = "fig/",
  dev = "png",
  comment = "#>"
)

# save some typing
knitr::set_alias(w = "fig.width",
                 h = "fig.height",
                 cap = "fig.cap")

# colorize text
colorize <- function(x, color) {
  if (knitr::is_latex_output()) {
    sprintf("\\textcolor{%s}{%s}", color, x)
  } else if (knitr::is_html_output()) {
    sprintf("<span style='color: %s;'>%s</span>", color,
      x)
  } else x
}


set.seed(47)
options(digits = 4)

# packages to be cited here. Code at the end automatically updates packages.bib
to.cite <- c("car", "broom", "ggplot2", "directlabels")
```

Load the packages we'll use here:
```{r setup}
library(nestedLogit)    # Nested Dichotomy Logistic Regression Models
library(knitr)          # A General-Purpose Package for Dynamic Report Generation in R
library(car)            # Companion to Applied Regression
library(broom)          # Convert Statistical Objects into Tidy Tibbles
library(ggplot2)        # Create Elegant Data Visualisations Using the Grammar of Graphics
library(directlabels)   # Direct Labels for Multicolor Plots
library(dplyr)          # A Grammar of Data Manipulation
```

## Models for polytomous responses

### Multinomial model
For a categorical ("_polytomous_") response variable with more than two response categories, 
one natural extension of the standard logistic regression _logit_ model is the _multinomial logit_ 
(or, _generalized logit_) model.
When the polytomous response has $m$ levels, the multinomial logit model is comprised of
$m-1$ log odds comparisons with a reference level, typically the last, as described in
@Fox:2016:ARA, \S 14.2.1 and @FriendlyMeyer:2016:DDAR, \S 8.3.
The standard implementation of this model is `multinom()` in the
`nnet` package.
<!-- TODO: reference R packages -->

### Nested logit model
A sometimes simpler approach, called _nested dichotomies_, is to fit a collection of $m-1$ 
separate models for each of a hierarchically nested set of binary comparisons among the
response categories.  This is simpler, 

* because it uses the familiar logistic regression model for each of the dichotomies, where standard methods
for model summaries and tests are widely available.
* Taken together, this set of $m-1$ models comprises a complete
model for the polytomous response, just as does the multinomial logit model.


This approach stems from @Fienberg:80 and
is described in @Fox:2016:ARA, \S 14.2.2 and @FriendlyMeyer:2016:DDAR, \S 8.2.

Moreover, by the construction of **nested** dichotomies, the submodels are 
`r colorize("statistically independent", "blue")` 
(because the likelihood for the polytomous response is the product of the likelihoods for
the dichotomies),
so that test statistics, such as the likelihood ratio $G^2$ tests and tests for
individual coefficients can be added to give overall tests for the full polytomy.
In this way, the $m-1$ dichotomies are analogous to $m-1$
`r colorize("orthogonal", "blue")` contrasts for a for an $m$-level factor in an ANOVA design.

Thus, when applicable, nested logit models give the best of two worlds: 

* **dichotomy models**: Think about, analyze, plot the separate model for each contrast among the response categories
* **overall model**: Summarize, analyze, plot the overall model comprising all categories.


Dichotomies are illustrated in the figure below, where response categories $Y = \{1, 2, 3, 4\}$
can be divided first as $\{1, 2\}$ vs. $\{3, 4\}$. Then these dichotomies can be
divided as $\{1\}$ vs. $\{2\}$ and then $\{3\}$ vs. $\{4\}$.
Alternatively, as shown in the right side of the figure, the response categories
can be divided progressively---
first: $\{1\}$ vs. $\{2, 3, 4\}$,
next: $\{2\}$ vs. $\{3, 4\}$, and
finally: $\{3\}$ vs. $\{4\}$.


```{r}
#| nested,
#| echo = FALSE,
#| out.width="80%",
#| fig.cap = "**Nested dichotomies**: The boxes show two different ways a four-category response can be represented as three nested dichotomies."
knitr::include_graphics("nested.jpg")
```
<!-- knitr::include_graphics(here::here("vignettes", "fig", "nested.jpg")) -->


This figure makes clear that nested dichotomies are not unique or equivalent.
Different choices will have different interpretations and different fitted probabilities.
Such models make the most sense when there are substantive reasons for considering the response
categories in terms of such dichotomies. For example, in the diagram above at the right, this would make sense if the categories were _ordered_, $1 < 2 < 3 < 4$, so each of the three submodels can be interpreted as `above_1`, `above_2`, `above_3`.
In this case, the scheme for generating the dichotomies is often called _continuation logits_.
<!-- $\mathrm{above}: \{1, 2, 3}$. -->

For another example, the figure below shows a case where psychiatric patients
are classified into four diagnostic categories.  These might be considered
ordered categories and dichotomized as in the 4-category above.
However, it might make better sense to dichotomize the non-normal groups into
a comparison of the depressed and manic group vs. schizophrenic and then
a final contrast of the depressed and manic categories. Then, a model predicting
diagnosis can be interpreted in terms of the log odds of being classed
for each of the dichotomies. By independence, ANOVA and coefficient tests for the 
full multi-category response are based on the sums over the three dichotomies.

```{r}
#| nested-psychiatric,
#| echo = FALSE,
#| out.width="70%",
#| fig.cap = "**Psychiatric classification**: The figure shows how four diagnostic categories might be represented by nested dichotomies."
knitr::include_graphics("nested-psychiatric.png")
```
<!-- knitr::include_graphics(here::here("vignettes", "fig", "nested-psychiatric.png")) -->

## Example: Women's labor force participation

For a main example, we consider the data set `Womenlf` from the `carData` package.
This data gives the responses of 263 women from a 1977 survey carried out by
the York University Institute for Social Research
[@Atkinson-etal:1984].
The variables are:

* `partic`: labor force participation, the response, with levels:
  + `fulltime`: working full-time
  + `not.work`: not working outside the home
  + `parttime` : working part-time.

* `hincome`: Husband's income, in \$1,000s
* `children`: Presence of children in the home, `absent` or `present`
* `region`: Region of Canada (`r paste(levels(Womenlf$region), collapse=", ")`)

The response, `partic` is a factor, but the levels are ordered
alphabetically. To correct this, we make it an ordered factor. At that time, the majority
of the 263 women surveyed were not working. 


```{r order-partic}
data(Womenlf, package = "carData")
Womenlf <- Womenlf |>
  mutate(partic = ordered(partic, 
                          levels = c("not.work", "parttime", "fulltime")))

table(Womenlf$partic)
```

The question is: How can we understand these womens' labor choices in terms of the available variables?

### Defining dichotomies

It is at least arguable to consider a woman's labor choice as first involving
a dichotomy (`work`) between women who are not working vs. those who are
(part time or full time). A second dichotomy (`full`) contrasts those who work
full time vs. part time, but among only those who work.

The two binary variables can be created by re-coding `partic` in the data frame
as follows.  
```{r recode}
Womenlf <- Womenlf |>
  mutate(work = ifelse(partic=="not.work", 0, 1)) |>
  mutate(full = case_when(
    work & partic == "fulltime" ~ 1,
    work & partic == "parttime" ~ 0)
  )
```

Note that the full sample of `r nrow(Womenlf)` cases is available for the `work` dichotomy,
while only `r sum(Womenlf$partic != "not.work")` cases are involved in the distinction between
part time and full time work. The relations of `partic` to these dichotomies can be seen
below:

```{r xtabs}
xtabs(~ partic + work, addNA=TRUE, data=Womenlf)
xtabs(~ partic + full, addNA=TRUE, data=Womenlf)
```


We could then fit the separate models for these dichotomies manually:

```{r submodels}
mod.work <- glm(work ~ hincome + children, family=binomial, data=Womenlf)
mod.full <- glm(full ~ hincome + children, family=binomial, data=Womenlf)
```

The two log odds models are:
<!-- equatiomatic::extract_eq(mod.work) -->
<!-- equatiomatic::extract_eq(mod.work) -->

$$
L_1 =\log\left[ \frac { P( \operatorname{work} = \operatorname{1} ) }{ 1 - P( \operatorname{work} = \operatorname{1} ) } \right] = \alpha_1 + \beta_{11}(\operatorname{hincome}) + \beta_{12}(\operatorname{children}_{\operatorname{present}})
$$
$$
L_2 = \log\left[ \frac { P( \operatorname{full} ) }{ 1 - P( \operatorname{full} ) } \right] = \alpha_2 + \beta_{21}(\operatorname{hincome}) + \beta_{22}(\operatorname{children}_{\operatorname{present}})
$$
But then, it would be difficult to obtain tests for the combined model,
get and plot predicted values and so forth.

### Using `dichotomy()` and `logits()`
Instead, the `nestedLogit` package provides an easier way. The `dichotomy()` function
creates a list of length two defining a single dichotomy. The `logits()` function
uses $m-1$ calls to `dichotomy()` to create a list of class `dichotomies`
containing the symbolic representation of these contrasts among the response categories.

```{r comparisons}
comparisons <- logits(work=dichotomy("not.work", c("parttime", "fulltime")),
                      full=dichotomy("parttime", "fulltime"))

comparisons
```
For convenience, there are functions to convert these dichotomies to a matrix or to
a character string representing the tree structure of the dichotomies.

```{r}
#| collapse = FALSE
as.matrix(comparisons)

as.character(comparisons)
```

### Fitting the nested logit model

To fit the model, we specify these `comparisons` as the `dichotomies` argument.
The model formula, `partic ~ hincome + children` specifies a main effects model
for husband's income and presence of young children.
```{r wlf.nested}
wlf.nested <- nestedLogit(partic ~ hincome + children, 
                          dichotomies = comparisons,
                          data=Womenlf)
```

The result, `wlf.nested` is a list containing the details of the model for the nested
dichotomy. The `models` component contains results equivalent to what was fit manually
above as `mod.work` and `mod.full`.

```{r names}
#| collapse = FALSE
names(wlf.nested)

names(wlf.nested$models) # equivalent: names(models(wlf.models))
```


### Methods

```{r child="partials/methods.Rmd"}
```


We illustrate some of these:

**Coefficients**: By default, `coef()` returns a matrix whose rows are the terms in the model and
whose columns represent the nested dichotomies.
The coefficients, $\mathbf{\beta_{i1}}$ give the changes in the
log odds of working vs. not working associated with a \$1,000 increase
in husband's income and with having children present vs. absent.
$\mathbf{\beta_{i2}}$ is similar for the log odds of working full time vs. part time
among those who are working.
$e^\mathbf{\beta}$ give the multiples of the odds for these comparisons.
```{r coef}
coef(wlf.nested)

# show as odds
exp(coef(wlf.nested))
```
Thus, the odds of both working and working full time decrease with husband's income.
Having young children also decreases the odds of both.

**Anova**: Gives Type II tests for each term in the model. Note that the `LR` $\chi^2$ and `df` for the `Combined Responses` is the sum of their values for the separate dichotomies.
```{r Anova}
Anova(wlf.nested)
```

**linearHypothesis**: For a given model, `car::linearHypothesis()` provides a very general method for
testing specific hypotheses about individual coefficients in a model or their linear combinations.
This is extended here in the `linearHypothesis` method for `"nestedLogit"` models.

For example, the following call tests the hypothesis that the coefficients for `hincome` and
`children` are simultaneously all equal to zero. This is equivalent to the test of the global
null model, $H_0 : \mathbf{B} = 0$ against an alternative that one or more coefficients $\beta_{ij} \ne 0$.

`linearHypothesis()` gives these tests for each of the submodels, `work`, `full` as well as for the combined model.

```{r linearHyp}
linearHypothesis(wlf.nested, c("hincome", "childrenpresent"))
```


**glance** and **tidy**: The `broom` package [@R-broom]
provides some methods for giving compact and tidy summaries of fitted models. The `glance` method for a `"nestedLogit"` model gives a one-line summary of the statistics
for each dichotomy. The `tidy` method combines the coefficients for the sub-models, together with test
statistics.

```{r}
glance(wlf.nested)   # summarize the sub-models

tidy(wlf.nested)     # summarize the coefficients
```


These functions make it easy to construct custom tables. For example, to extract the likelihood ratio
`deviance` ($G^2$) goodness-of fit tests and compute ($G^2 / df$), you could do:
```{r}
gl <- glance(wlf.nested)
gl |> 
  select(response, deviance, df.residual) |> 
  add_row(response = "Combined", deviance = sum(gl$deviance), df.residual = sum(gl$df.residual)) |>
  mutate(
    `P-value` = pchisq(deviance, df.residual, lower.tail = FALSE),
    `$G^2$/df` = deviance / df.residual) |>
  rename(`$G^2$` = deviance,
         df = df.residual) |>
  knitr::kable(digits = 3)
```


**update**: Makes it easy to create a new model from an old one, by adding/subtracting terms from the
model formula or changing the observations used or contrasts for factors.

For example: You might ask: "_Does it make sense to include `region` of Canada in the model?_"  
This can be tested
by adding it to the model formula, and comparing the new model with the original one using
`anova()`. The significance tests here are for the additional contribution of `region` over
the model that just includes main effects of `husincome` and `children`.

```{r update}
wlf.nested.1 <- update(wlf.nested, formula = . ~ . + region)

anova(wlf.nested, wlf.nested.1)
```

Note that `anova()` with two or models tests these against one another, in the order specified.
This assumes that the models compared are _nested_ (an unintentional a pun), in the sense that the
terms in the smaller model are a subset of those in the larger model.

In a similar way, we could fit and test a _larger_ scope of models. For example to add
an interaction between husband's income and children:

```{r more-models}
#| eval = TRUE
wlf.nested.2 <- update(wlf.nested, formula = . ~ .^2)
anova(wlf.nested, wlf.nested.2)
```

We can see neither `region` nor an interaction make a difference in goodness of fit of 
either of the sub-models or the combined model for the three response categories.


## Obtaining fitted values: `predict()` 

By default, `predict()` for a `"nestedLogit"` model object returns the predicted probabilities
(`type = "response"`) of
each of the response categories for _all_ observations in the data set.
Note that the computation is a bit tricky, because the probabilities of working full time
or part time are conditional on working outside the home.

```{r}
car::some(predict(wlf.nested))
```

## Plotting
The `nestedLogit` package has a basic `plot()` method for `"nestedLogit"` models.
It calculates fitted probabilities for the response categories and plots these
against a single explanatory variable
on the horizontal axis and other explanatory variables fixed to particular values.
To produce multi-panel plots, it is necessary to call this repeatedly for
levels of other variables, and compose these into a single figure using `par()`
(or `knitr` chunk options):

```{r wlf-plot}
#| out.width = "100%",
#| fig.height = 4,
#| fig.cap = "**plot method**: Predicted probabilities of working at all or working part time or full time"
op <- par(mfcol=c(1, 2), mar=c(4, 4, 3, 1) + 0.1)
plot(wlf.nested, "hincome", list(children="absent"),
     xlab="Husband's Income", legend.location="top")
plot(wlf.nested, "hincome", list(children="present"),
     xlab="Husband's Income", legend=FALSE)
```


### Constructing plots
To explain how this works, and for better control of the details,
it is useful to describe how this can be done directly.

To construct a plot, it is sufficient to calculate predicted probabilities over a grid of
values of the predictor variables. Here, we select a range of 0 - 45 in steps of 5,
combined with the two values of `children`.

```{r plotdata}
new <- expand.grid(hincome=seq(0, 45, by = 5), 
                   children=c("absent", "present"))

pred.nested <- predict(wlf.nested, newdata = new)
plotdata <- cbind(new, pred.nested)
head(plotdata)
```

Because the fitted values are in multiple columns, it is easiest to plot these using
`matplot()`. We could plot these all in a single (messy) figure, but it is clearer
to show separate panels for children `absent` and `present`.

To do this, the `plotdata` data set is subset within a loop over the values of `children`
and each subset is plotted by `matplot`. It is only necessary to include the legend
in one panel. The plots are combined into a single figure using `par(mfrow())`.
```{r wlf-matplot}
#| out.width = "100%",
#| fig.height = 4,
#| fig.cap = "**matplot**: Predicted probabilities of working at all or working part time or full time"
op <- par(mfrow=c(1,2), mar=c(4,4,3,1)+.1)
cols=c("blue", "magenta", "darkgreen")
for ( kids in c("absent", "present") ) {
  data <- subset(plotdata, children==kids)
  matplot(data[, "hincome"], data[, 5:3], 
          type = "l", lwd=3, lty = 1:3, col = cols,
          xlab="Husband's Income", 
          ylab='Fitted Probability',
          main = paste("Children", kids),
          cex.lab = 1.1)
  if (kids=="absent") {
    legend("topright", lty=1:3, lwd=3, col=cols, bty = "n",
           legend=c("fulltime", "parttime", "not working"))
  }
}
```

### Using `ggplot`

More control, and perhaps a more aesthetically pleasing figure can be produced using `ggplot`
[@R-ggplot2].
However, `ggplot` wants the data in long format. That makes it easy to plot probability
against one predictor and use `color` to distinguish the levels of
`partic` and facet the plot by `children`.
<!-- (The result of `tidyr::pivot_longer()` doesn't recognize an ordered nature of `"Working"`, -->
<!-- so this must be done in a separate step.) -->


```{r plotlong}
plotlong <- plotdata |>
  tidyr::pivot_longer(fulltime : not.work,
                      names_to = "Working",
                      values_to = "Probability") |>
  mutate(Working = ordered(Working, 
                           levels = c("not.work", "parttime", "fulltime")) )

head(plotlong)
```

Then, one call to `ggplot` produces both panels. To sort the levels of `Working` appropriately,
we made this an ordered factor in the step above, but assign the colors with a discrete scale.
```{r wlf-ggplot}
#| out.width = "100%",
#| fig.height = 4,
#| fig.cap = "**ggplot**: Predicted probabilities of working at all or working part time or full time"

gg <- ggplot(plotlong,
             aes(x=hincome, y=Probability, color=Working)) +
  geom_line(linewidth = 2) +
  scale_color_discrete() +
  labs(x="Husband's Income", y= "Probability") +
  facet_wrap(~ children, labeller = label_both) +
  theme_bw(base_size = 14) +
  theme(legend.position = c(.3, .8))
gg
```

### Direct labels

It's usually nicer to label the curves directly than to rely on a legend.
The `directlabels` package [@R-directlabels]
can take a `ggplot` object, remove the legend and
place labels along the curves. It is a little fiddly, and we haven't tried
to make it avoid clipping some of the labels.

```{r wlf-directlabels}
#| out.width = "100%",
#| fig.height = 4,
#| fig.cap = "**direct labels**: Predicted probabilities, with labels on the curves"
direct.label(gg, list("top.bumptwice", dl.trans(y = y + 0.2)))
```


### Plotting fitted log odds

It is sometimes easier to interpret logistic regression models by plotting the linear predictors
on the **log odds** scale, because these appear as straight lines. That is, from the estimated
coefficients in the model, the predicted log odds of `work` and `full` are given by

<!-- equatiomatic::extract_eq(wlf.nested$models[[1]], use_coefs = TRUE) -->
<!-- equatiomatic::extract_eq(wlf.nested$models[[2]], use_coefs = TRUE) -->

$$
L_1 =\log\left[ \frac { \widehat{P( \operatorname{work} = \operatorname{1} )} }{ 1 - \widehat{P( \operatorname{work} = \operatorname{1} )} } \right] = 1.34 - 0.04(\operatorname{hincome}) - 1.58(\operatorname{children}_{\operatorname{present}})
$$

$$
L_2 =\log\left[ \frac { \widehat{P( \operatorname{full} = \operatorname{1})} }{ 1 - \widehat{P( \operatorname{full} = \operatorname{1})} } \right] = 3.48 - 0.11(\operatorname{hincome}) - 2.65(\operatorname{children}_{\operatorname{present}})
$$
Here, $\operatorname{children}_{\operatorname{present}}$ is either 0 or 1, so this
amounts to a shift in the intercept when children are present.

These values can be calculated by calling `predict.glm()` directly for the
`models` component of `wlf.nested`, specifying `type = "link"`:

```{r}
pred.logits <- sapply(models(wlf.nested), predict, newdata=new, type = "link")
plotdatal <- cbind(new, pred.logits)
head(plotdatal)
```

Then we plot these more or less as before:
```{r wlf-logits}
#| out.width = "100%",
#| fig.height = 4,
#| fig.cap = "**log odds**: Predicted logits of the  `work` and `full` dichotomies"
cols=c("blue", "red")

op <- par(mfrow=c(1,2), mar=c(4,4,3,1)+.1)
for ( kids in c("absent", "present") ) {
  data <- subset(plotdatal, children==kids)
  matplot(data[, "hincome"], data[, 3:4],
          type = "l", lwd=3, lty = 1, col = cols,
          xlab="Husband's Income",
          ylab='Predicted Log Odds',
          main = paste("Children", kids),
          cex.lab = 1.1)
  if (kids=="absent") {
    legend("topright", lty=1, lwd=3, col=cols, bty = "n",
           title = "Dichotomy",
           legend=c("work", "full"))
  }
}
```

Finally, we can use `ggplot` as before to plot the fitted logits, first transforming the long format.

```{r}
plotlongl <- plotdatal |>
  tidyr::pivot_longer(work : full,
                      names_to = "Dichotomy",
                      values_to = "logit") |>
  mutate(Dichotomy = ordered(Dichotomy,
                         levels = c("work", "full")) )
```

Doing this gives the flexibility that we can facet the plot either by `children` (as before)
or `Dichotomy`. The latter nicely shows that the additive model has equal slopes for husband's
income within both panels: increasing husband's income decreases the log odds of working,
but at a faster rate for the `full` dichotomy.
Having young children decreases the log odds of working either at all
or working fulltime as compared to parttime.
```{r wlf-gglogits}
#| out.width = "100%",
#| fig.height = 4,
#| fig.cap = "**log odds**: Predicted logits of the  `work` and `full` dichotomies"
ggplot(plotlongl,
       aes(x=hincome, y=logit, color=children)) +
  geom_line(linewidth = 3) +
  geom_point(size = 1.5, shape = 16, color = "black") +
  scale_color_discrete() +
  labs(x="Husband's Income", y= "Log Odds") +
  facet_wrap(~ Dichotomy, labeller = label_both) +
  theme_bw(base_size = 14) +
  theme(legend.position = c(.35, .82))

```


```{r write-bib}
# write a packages.bib file of the packages (.packages()) that have been used here
knitr::write_bib(file = here::here("vignettes", "packages.bib"))
```

## References





