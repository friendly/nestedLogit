---
title: "Nested dichotomies logistic regression models"
author: "Michael Friendly and John Fox"
date: "`r Sys.Date()`"
package: nestedLogit
output: 
  rmarkdown::html_vignette:
  fig_caption: yes
bibliography: ["references.bib", "packages.bib"]
csl: apa.csl
vignette: >
  %\VignetteIndexEntry{Nested dichotomies logistic regression models}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  message = FALSE,
  warning = FALSE,
  fig.align = "center",
  fig.height = 6,
  fig.width = 7,
  fig.path = "fig/",
  dev = "png",
  comment = "#>"
)

# save some typing
knitr::set_alias(w = "fig.width",
                 h = "fig.height",
                 cap = "fig.cap")

# colorize text
colorize <- function(x, color) {
  if (knitr::is_latex_output()) {
    sprintf("\\textcolor{%s}{%s}", color, x)
  } else if (knitr::is_html_output()) {
    sprintf("<span style='color: %s;'>%s</span>", color,
      x)
  } else x
}


set.seed(47)
options(digits = 4)

# packages to be cited here. Code at the end automatically updates packages.bib
to.cite <- c("car", "broom", "ggplot2", "directlabels")
```

Load the packages we'll use here:
```{r setup}
library(nestedLogit)    # Nested Dichotomy Logistic Regression Models
library(knitr)          # A General-Purpose Package for Dynamic Report Generation in R
library(car)            # Companion to Applied Regression
library(broom)          # Convert Statistical Objects into Tidy Tibbles
library(ggplot2)        # Create Elegant Data Visualisations Using the Grammar of Graphics
library(directlabels)   # Direct Labels for Multicolor Plots
```

## Models for polytomous responses

### Multinomial model
For a categorical ("_polytomous_") response variable with more than two response categories, 
one natural extension of the standard logistic regression _logit_ model is the _multinomial logit_ 
(or, _generalized logit_) model.
When the polytomous response has $m$ levels, the multinomial logit model is comprised of
$m-1$ log odds comparisons with a reference level, typically the last, as described in
@Fox:2016:ARA, \S 14.2.1 and @FriendlyMeyer:2016:DDAR, \S 8.2.
The standard implementation of this model is `multinom()` in the
`nnet` package.
<!-- TODO: reference R packages -->

### Nested logit model
A sometimes simpler approach, called _nested dichotomies_, is to fit a collection of $m-1$ 
separate models for each of a hierarchically nested set of binary comparisons among the
response categories.  This is simpler, because it uses the familiar logistic regression model
for each of the dichotomies. Taken together, this set of $m-1$ models comprises a complete
model for the polytomous response, just as does the multinomial logit model.

However, by the construction of **nested** dichotomies, the submodels are statistically independent,
so that test statistics, such as the likelihood ratio $G^2$ tests and tests for
individual coefficients can be added to give overall tests for the full polytomy.

This is illustrated in the figure below, where response categories $Y = \{1, 2, 3, 4\}$
can be divided first as $\{1, 2\}$ vs. $\{3, 4\}$. Then these dichotomies can be
divided as $\{1\}$ vs. $\{2\}$ and then $\{3\}$ vs. $\{4\}$.
Alternatively, as shown in the right side of the figure, the response categories
can be divided progressively---
first: $\{1\}$ vs. $\{2, 3, 4\}$,
next: $\{2\}$ vs. $\{3, 4\}$, and
finally: $\{3\}$ vs. $\{4\}$.


```{r}
#| nested,
#| echo = FALSE,
#| out.width="80%",
#| fig.cap = "**Nested dichotomies**: The boxes show two different ways a four-category response can be represented as three nested dichotomies."
knitr::include_graphics("nested.jpg")
```
<!-- knitr::include_graphics(here::here("vignettes", "fig", "nested.jpg")) -->


This figure makes clear that nested dichotomies are not unique or equivalent.
Different choices will have different interpretations and different fitted probabilities.
Such models make the most sense when there are substantive reasons for considering the response
categories in terms of such dichotomies. For example, in the diagram above at the right, this would make sense if the categories were _ordered_, $1 < 2 < 3 < 4$, so each of the three submodels can be interpreted as `above_1`, `above_2`, `above_3`.
<!-- $\mathrm{above}: \{1, 2, 3}$. -->

For another example, the figure below shows a case where psychiatric patients
are classified into four diagnostic categories.  These might be considered
ordered categories and dichotomized as in the 4-category above.
However, it might make better sense to dichotomize the non-normal groups into
a comparison of the depressed and manic group vs. schizophrenic and then
a final contrast of the depressed and manic categories.

```{r}
#| nested-psychiatric,
#| echo = FALSE,
#| out.width="70%",
#| fig.cap = "**Psychiatric classification**: The figure shows how four diagnostic categories might be represented by nested dichotomies."
knitr::include_graphics("nested-psychiatric.png")
```
<!-- knitr::include_graphics(here::here("vignettes", "fig", "nested-psychiatric.png")) -->

## Example: Women's labor force participation

For a main example, we consider the data set `Womenlf` from the `carData` package.
This data gives the responses of 263 women from a 1977 survey carried out by
the York University Institute for Social Research
[@Atkinson-etal:1984].
The variables are:

* `partic`: labor force participation, the response, with levels
  + `fulltime`: working full-time
  + `not.work`: not working outside the home
  + `parttime` : working part-time.

* `hincome`: Husband's income, in \$1,000s
* `children`: Presence of children in the home, `absent` or `present`
* `region`: Region of Canada

The response, `partic` is a factor, but the levels are ordered
alphabetically. To correct this, we make it an ordered factor. At that time, the majority
of the 263 women surveyed where not working. 


```{r order-partic}
library(dplyr) # A Grammar of Data Manipulation
data(Womenlf, package = "carData")
Womenlf <- Womenlf |>
  mutate(partic = ordered(partic, 
                          levels = c("not.work", "parttime", "fulltime")))

table(Womenlf$partic)
```

The question is: How can we understand these womens' labor choices in terms of the available variables?

### Defining dichotomies

It is at least arguable to consider a woman's labor choice as first involving
a dichotomy (`work`) between women who are not working vs. those who are
(part time or full time). A second dichotomy (`full`) contrasts those who work
full time vs. part time, but among only those who work.

the two binary variables can be created by recoding `partic` in the data frame
as follows.  
```{r recode}
Womenlf <- Womenlf |>
  mutate(work = ifelse(partic=="not.work", 0, 1)) |>
  mutate(full = case_when(
    work & partic == "fulltime" ~ 1,
    work & partic == "parttime" ~ 0)
  )
```

Note that the full sample of `r nrow(Womenlf)` cases is available for the `work` dichotomy,
while only `r sum(Womenlf$partic != "not.work")` cases are involved in the distinction between
part time and full time work.

```{r xtabs}
xtabs(~ partic + work, addNA=TRUE, data=Womenlf)
xtabs(~ partic + full, addNA=TRUE, data=Womenlf)
```


We could then fit the separate models for these dichotomies manually:

```{r submodels}
mod.work <- glm(work ~ hincome + children, family=binomial, data=Womenlf)
mod.full <- glm(full ~ hincome + children, family=binomial, data=Womenlf)
```

But then, it would be difficult to obtain tests for the combined model,
get and plot predicted values and so forth.

### Using `dichotomy()` and `logits()`
Instead, the `nestedLogit` package provides an easier way. The `dichotomy()` function
creates a list of length two defining a single dichotomy. The `logits()` function
uses $m-1$ calls to `dichotomy()` to create a list of class `dichotomies`
containing the symbolic representation of these contrasts among the response categories.

```{r comparisons}
comparisons <- logits(work=dichotomy("not.work", c("parttime", "fulltime")),
                      full=dichotomy("parttime", "fulltime"))

comparisons
```
For convenience, there are functions to convert these dichotomies to a matrix or to
a character string representing the tree structure of the dichotomoies.

```{r}
as.matrix(comparisons)
as.character(comparisons)
```

### Fitting the nested logit model

To fit the model, we specify these `comparisons` as the `dichotomies` argument.
```{r wlf.nested}
wlf.nested <- nestedLogit(partic ~ hincome + children, 
                          dichotomies = comparisons,
                          data=Womenlf)
```

The result, `wlf.nested` is a list containing the details of the model for the nested
dichotomy. The `models` component contains results equivalent to what was fit manually
above as `mod.work` and `mod.full`.

```{r names}
names(wlf.nested)
names(wlf.nested$models)
```


### Methods

As befits a model-fitting function, the package defines a nearly complete set of methods for class `nested` objects:

* `print()`, `summary()`: prints the results for each of the submodels
* `update()` re-fits a model, allowing changes in the model `formula`, `data`, `subset`, and `contrasts`.
* `coef()` returns the coefficients for the predictors in each dichotomy
* `vcov()` returns the variance-covariance matrix of the predictors
* `anova()` provides ANOVA Type I (sequential) tests for each dichotomy and for the combined model. When given a sequence of objects, anova tests the models against one another in the order specified.
* `Anova()` uses `car::Anova()` to provide ANOVA Type II (partial) tests for each dichotomy and for the combined model.
* `anova()` provides ANOVA analysis of deviance tables for one or more fitted model objects.
* `predict()` obtains predicted probabilities for the response categories, useful for producing plots to aid interpretation.
* `glance()`, `tidy()` are extensions of `broom::glance.glm()` and `broom::tidy.glm()` to obtain compact summaries of a `nested` model object`.

We illustrate some of these:

**Coefficients**: By default, `coef()` returns a matrix whose rows are the terms in the model and
whose columns represent the nested dichotomies.
The coefficients, $\mathbf{\beta_{i1}}$ give the changes in the
log odds of working vs. not working associated with a \$1,000 increase
in husband's income and with having children present vs. absent.
$\mathbf{\beta_{i2}}$ is similar for the log odds of working full time vs. part time
among those who are working.
$e^\mathbf{\beta}$ give the multiples of the odds for these comparisons.
```{r coef}
coef(wlf.nested)

exp(coef(wlf.nested))
```
Thus, the odds of both working and working full time decrease with husband's income.
Having young children also decreases the odds of both.

**Anova**: Gives Type II tests for each term in the model. Note that the `LR` $\chi^2$ and `df` for the `Combined Responses` is the sum of their values for the separate dichotomies.
```{r Anova}
Anova(wlf.nested)
```

**glance** and **tidy**: The `broom` package provides some methods for giving compact and tidy summaries of fitted models. The `glance` method for a `"nested"` model gives a one-line summary of the statistics
for each dichotomy. The `tidy method combines the coefficients for the sub-models, together with test
statistics.

```{r}
glance(wlf.nested)   # summarize the sub-models

tidy(wlf.nested)     # summarize the coefficients
```

<!-- TODO: ??? -->
<!--   illustrate how the result of glance can be manipulated to produce a custom table -->
<!-- > gl <- glance(wlf.nested) -->
<!-- > gl |> select(response, deviance, df.residual) |> mutate(`G2/df` = deviance / df.residual) -->
<!-- # A tibble: 2 × 4 -->
<!--   response deviance df.residual `G2/df` -->
<!--   <chr>       <dbl>       <int>   <dbl> -->
<!-- 1 work         320.         260   1.23  -->
<!-- 2 full         104.         105   0.995 -->


**update**: Does it make sense to include `region` of Canada in the model?  This can be tested
by adding it to the model formula, and comparing the new model with the original one using
`anova()`. The significance tests here are for the additional contribution of `region` over
the model that just includes main effects of `husincome` and `children`.

```{r update}
wlf.nested.1 <- update(wlf.nested, formula = . ~ . + region)

anova(wlf.nested, wlf.nested.1)
```

Note that `anova()` with two or models tests these against one another, in the order specified.
This assumes that the models compared are _nested_ (is this a pun?), in the sense that the
terms in the smaller model are a subset of those in the larger model.

In a similar way, we could fit and test a larger scope of models. For example to add
an interaction between husband's income and children:

```{r more-models}
#| eval = TRUE
wlf.nested.2 <- update(wlf.nested, formula = . ~ .^2)
anova(wlf.nested, wlf.nested.2)
```

We can see neither `region` nor an interaction make a difference in goodness of fit of 
either of the sub-models or the combined model for the three response categories.


## Obtaining fitted values: `predict()` 

By default, `predict()` for a `"nested"` model object returns the predicted probabilities
(`type = "response"`) of
each of the response categories for _all_ observations in the data set.
Note that the computation is a bit tricky, because the probabilities of working full time
or part time are conditional on working outside the home.

```{r}
car::some(predict(wlf.nested))
```

## Plotting
To construct a plot, it is sufficient to calculate predicted probabilities over a grid of
values of the predictor variables. Here, we select a range of 0 - 45 in steps of 5,
combined with the two values of `children`.

```{r plotdata}
new <- expand.grid(hincome=seq(0, 45, by = 5), 
                   children=c("absent", "present"))

pred.nested <- predict(wlf.nested, newdata = new)
plotdata <- cbind(new, pred.nested)
head(plotdata)
```

Because the fitted values are in multiple columns, it is easiest to plot these using
`matplot()`. We could plot these all in a single (messy) figure, but it is clearer
to show separate panels for children `absent` and `present`.

To do this the `plotdata` data set is subset within a loop over the values of `children`
and each subset is plotted by `matplot`. It is only necessary to include the legend
in one panel. The plots are combined into a single figure using `par(mfrow())`.
```{r wlf-matplot}
#| out.width = "100%",
#| fig.height = 4,
#| fig.cap = "**matplot**: Predicted probabilities of working at all or workinn part time or full time"
op <- par(mfrow=c(1,2), mar=c(4,4,3,1)+.1)
cols=c("blue", "magenta", "darkgreen")
for ( kids in c("absent", "present") ) {
  data <- subset(plotdata, children==kids)
  matplot(data[, "hincome"], data[, 5:3], 
          type = "l", lwd=3, lty = 1:3, col = cols,
          xlab="Husband's Income", 
          ylab='Fitted Probability',
          main = paste("Children", kids),
          cex.lab = 1.1)
  if (kids=="absent") {
    legend("topright", lty=1:3, lwd=3, col=cols, bty = "n",
           legend=c("fulltime", "parttime", "not working"))
  }
}
```

### Using `ggplot`

More control, and perhaps a more aesthetically pleasing figure can be produced using `ggplot`
[@R-ggplot2].
However, `ggplot` wants the data in long format. That makes it easy to plot probability
against one predictor and use `color` to distinguish the levels of
`partic` and facet the plot by `children`.
<!-- (The result of `tidyr::pivot_longer()` doesn't recognize an ordered nature of `"Working"`, -->
<!-- so this must be done in a separate step.) -->


```{r plotlong}
plotlong <- plotdata |>
  tidyr::pivot_longer(fulltime : not.work,
                      names_to = "Working",
                      values_to = "Probability") |>
  mutate(Working = ordered(Working, 
                           levels = c("not.work", "parttime", "fulltime")) )

head(plotlong)
```

Then, one call to `ggplot` produces both panels. To sort the levels of `Working` appropriately,
we made this an ordered factor in the step above, but assign the colors with a discrete scale.
```{r wlf-ggplot}
#| out.width = "100%",
#| fig.height = 4,
#| fig.cap = "**ggplot**: Predicted probabilities of working at all or working part time or full time"

gg <- ggplot(plotlong,
             aes(x=hincome, y=Probability, color=Working)) +
  geom_line(linewidth = 2) +
  scale_color_discrete() +
  labs(x="Husband's Income", y= "Probability") +
  facet_wrap(~ children, labeller = label_both) +
  theme_bw(base_size = 14) +
  theme(legend.position = c(.3, .8))
gg
```

### Direct labels

It's usually nicer to label the curves directly than to rely on a legend.
The `directlabels` package [@R-directlabels]
can take a `ggplot` object, remove the legend and
place labels along the curves. It is a little fiddly, and we haven't tried
to make it avoid clipping some of the labels.

```{r wlf-directlabels}
#| out.width = "100%",
#| fig.height = 4,
#| fig.cap = "**direct labels**: Predicted probabilities, with labels on the curves"
direct.label(gg, list("top.bumptwice", dl.trans(y = y + 0.2)))
```

```{r write-bib}
# write a packages.bib file of the packages (.packages()) that have been used here
knitr::write_bib(file = here::here("vignettes", "packages.bib"))
```

### Plotting fitted log ods



## References





